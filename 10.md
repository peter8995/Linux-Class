# ping 腳本
* gedit ping.sh
* 
```
#!/usr/bin/bash

ip=$1                                    //取要ping的IP ex. ./ping.sh 8.8.8.8 就會取8.8.8.8到ip內
$(ping -c 1 -W 1 $ip &> /dev/null)       //-W timeout時間1秒、不要ping的內容，丟到null
result=$(echo $?)                        //把echo $?的執行結果丟到result
if [ $result -eq 0 ]; then
  echo "ping ok"
else
  echo "ping fail"
fi
```
* chomod +x ping.sh
* ./ping.sh 8.8.8.8

# 搜尋檔案
* locate 
  * 從資料庫內搜尋
  * 先使用updatedb更新資料庫之後再搜尋
* find 
  * 直接在系統內搜尋檔案
  * find [開始搜尋的目錄(若無則從目前目錄開始)] -[條件 ex.name]

# 指令
* 檔案合併
  * echo "hello" > 1.txt
  * echo "john" > 2.txt
  * cat 1.txt 2.txt > 3.txt
  * cat 3.txt     會輸出hello john
* ls /aaa 1 > output.txt 2>&1
  * 標準輸出改成output.txt，把2(standard error)改成跟1(standard output)一樣
* ls /aaa 2 > output.txt 1>&2
  * 標準錯誤改成output.txt，把1(standard output)改成跟2(standard error)一樣
* ls /aaa &> output.txt
  * 把1、2一起改成output.txt
* 查詢現在所用的shell 
  * echo $SHELL
* tee
  * cat 3.txt | tee 4.txt
  * 會同時輸出3.txt且把資料輸入到4.txt
  
# 管道
* 指令A | 指令B
  * 前面的輸出會當作後面的輸入
  
# 雜記
* result = 'echo $?'
    result = $(echo $?)
  * 都是把echo $?執行完再把結果傳給result
* 通配符
  * \*代表0個字元
  * ?  代表一個字元
  * [] 匹配括弧中任一個字母，不論順序
    '''
    [root@localhost 1]# touch aa.txt bb.txt cc.txt a.txt b.txt abcd.txt
    [root@localhost 1]# ls
    aa.txt  abcd.txt  a.txt  bb.txt  b.txt  cc.txt
    [root@localhost 1]# ls *.txt
    aa.txt  abcd.txt  a.txt  bb.txt  b.txt  cc.txt
    [root@localhost 1]# ls ?.txt
    a.txt  b.txt
    [root@localhost 1]# ls ??.txt
    aa.txt  bb.txt  cc.txt
    [root@localhost 1]# ls [abd].txt
    a.txt  b.txt
    '''
